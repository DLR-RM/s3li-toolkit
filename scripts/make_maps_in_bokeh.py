# -*- coding: utf-8 -*-
"""Make_Maps_in_Bokeh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tcNy8cQ3OkK1xwvwD3sd8ra46Q39nSLu

#How to Make Interactive Maps in Python Using Bokeh
Let's face it: clients love dashboards. No matter how much progress is made in the field of data science, the visualization dashboard will remain a trusty tool in at the belt of data scientists everywhere. One way to step up your dashboard-creation skillset and take it to the next level is by implementing spatial data! Spatial data is geographic data, usually using lat/lon coordinates. There are many options for the aspiring data scientist to deal with spatial data: arcGIS and other GIS software for more advanced users who deal primarily and spatial data, and common python libraries like geopandas and folium for those first forays into spatial visualization. 

This tutorial will teach you to make maps in Bokeh, a python dashboard-creation library that facilitates high levels of interactivity in your plots. Bokeh is rarely mentioned in the realm of spatial data and map-making, but this tutorial aims to teach you to make stunning interactive map visualizations using Bokeh; you may never use folium again!
"""

import pandas as pd

from bokeh.models import *
from bokeh.plotting import *
from bokeh.io import *
from bokeh.tile_providers import *
from bokeh.palettes import *
from bokeh.transform import *
from bokeh.models import Arrow, OpenHead

import os
import argparse

"""
Generator to return dataframes for each sequence
"""
def read_and_merge_dataframes(sequences, base_path):
    df = None

    for sequence in sequences:
        path = os.path.join(base_path, sequence, sequence + '.pkl')

        if not os.path.isfile(path):
            print("Could not sequence from pickle " + str(path))
            continue

        df_current = pd.read_pickle(path)
        df_current['overlay'] = df_current['overlay'].replace("s3li_crater_inout", "s3li_zcrater_inout")
        df_current['time_stamp'] = pd.to_datetime(df_current['time_stamp'], unit='s').apply(
            lambda x: x.strftime('%Y/%m/%d - %H:%M:%S'))

        if df is None:
            df = df_current
        else:
            df = pd.concat([df, df_current], ignore_index=True)

        print("Read sequence from pickle " + str(path))
    return df


"""
Return downsampled dataframe for speeding up the visualization
"""
def filter_dataframe_for_visualization(sequences_dataframe, skip):
    mask = sequences_dataframe.index % skip == 0
    return sequences_dataframe.loc[mask]


# Generate colormap from sequence list 
def create_colormap_for_sequences(sequences):
    return linear_cmap(field_name='sequence_index', palette=Spectral6, low=0, high=len(sequences))


# Bokeh maps are in mercator. Convert lat lon fields to mercator units for plotting
def wgs84_to_web_mercator(df, lon, lat):
    """Converts decimal longitude/latitude to Web Mercator format"""
    k = 6378137
    df["x"] = df[lon] * (k * np.pi / 180.0)
    df["y"] = np.log(np.tan((90 + df[lat]) * np.pi / 360.0)) * k
    return df


"""
Computes the range of the map, depending on the dataframe values and scale. 
@return (x_min, x_max, y_min, y_max)
"""
def compute_map_ranges(sequences_dataframe, scale):
    x = df['x'].values
    y = df['y'].values

    # The range for the map extents is derived from the lat/lon fields. This way the map is automatically centered on the plot elements.
    x_min = int(x.mean() - (scale * 350))
    x_max = int(x.mean() + (scale * 350))
    y_min = int(y.mean() - (scale * 350))
    y_max = int(y.mean() + (scale * 350))

    return x_min, x_max, y_min, y_max


def initialize_base_plot(sequences_dataframe, scale=1):
    sequences_dataframe = wgs84_to_web_mercator(sequences_dataframe, 'longitude', 'latitude')

    # Get northing
    #A = np.array(df["orientation"].apply(lambda x: x[-1]).values)
    A = df["orientation"].values
    print(A.shape)
    arrow_x = np.cos(A)
    arrow_y = np.sin(A)

    df["arrow_x"] = df['x'] + arrow_x * 0.5
    df["arrow_y"] = df['y'] + arrow_y * 0.5

    # Establish the bokeh plot object and add the map tile as an underlay. Hide x and y axis.
    x_min, x_max, y_min, y_max = compute_map_ranges(sequences_dataframe, scale)

    plot = figure(
        title='Mt. Etna Dataset',
        match_aspect=True,
        tools='wheel_zoom,pan,reset,save',
        x_range=(x_min, x_max),
        y_range=(y_min, y_max),
        x_axis_type='mercator',
        y_axis_type='mercator',
        sizing_mode="stretch_both"
    )

    plot.grid.visible = True

    plot.xaxis.visible = False
    plot.yaxis.visible = False
    plot.title.text_font_size = "20px"

    return plot


# function takes scale (defined above), the initialized plot object, and the converted dataframe with mercator
# coordinates to create a hexbin map
def hex_map(plot, df, scale, leg_label='Hexbin Heatmap'):
    r, bins = plot.hexbin(df['x'].values, df['y'].values, size=scale * 10, hover_color='pink', hover_alpha=0.8, legend_label=leg_label)
    hex_hover = HoverTool(tooltips=[('count', '@c')], mode='mouse', point_policy='follow_mouse', renderers=[r])
    hex_hover.renderers.append(r)
    plot.tools.append(hex_hover)

    plot.legend.location = "top_right"
    plot.legend.click_policy = "hide"


# function takes a column to determine radius and the dataframe with converted mercator coordinates to create a bubble map.
def bubble_map(plot, df, lon, lat, scale, colormap, leg_label='default'):
    radius_col = "point"

    source = ColumnDataSource(df)
    c = plot.circle(x='x', y='y', line_color=colormap, color=colormap, source=source, size=1,
                    fill_alpha=0.4, legend_label=leg_label, hover_color='red')

    tip_label = '@' + radius_col
    lat_label = '@' + lat
    lon_label = '@' + lon

    circle_hover = HoverTool(tooltips=[(radius_col, tip_label), ('Lat:', lat_label), ('Lon:', lon_label)], mode='mouse',
                             point_policy='follow_mouse', renderers=[c])
    circle_hover.renderers.append(c)
    plot.tools.append(circle_hover)

    # The legend.click_policy method allows us to toggle layer on/off by clicking the corresponding field in the legend.
    plot.legend.location = "top_right"
    plot.legend.click_policy = "hide"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Create a Bokeh plot, to inspect the generated dataset')
    parser.add_argument('base_path', type=str, help='path to root folder, which contains each individual'
                                                    'sequence as subfolder (generated by create_dataset.py)')
    parser.add_argument('skip', type=int, default=10, help='Factor to downsample the data for visualization')

    args = parser.parse_args()

    skip = args.skip
    scale = 1

    # All possible sequences
    sequences = ["s3li_traverse_1",
                 "s3li_loops",
                 "s3li_traverse_2",
                 "s3li_crater",
                 "s3li_crater_inout",
                 "s3li_mapping",
                 "s3li_landmarks"]

    # Get colormap (1 color / sequence)
    mapper = create_colormap_for_sequences(sequences)

    df = read_and_merge_dataframes(sequences, args.base_path)
    df['sequence_index'] = pd.factorize(df['seq_name'])[0]

    df = df.iloc[::skip]

    # Dump views of GNSS, for debug
    #fig, axs = plt.subplots(1, 1, figsize=(6, 6))
    #axs.plot(df['longitude'].values, df['latitude'].values, label="GNSS-DEBUG")
    #print(np.column_stack((df['longitude'].values, df['latitude'].values)).shape)
    #axs.quiver(df['longitude'].values, df['latitude'].values, np.cos(df["orientation"].values), np.sin(df["orientation"].values))
    #print(df['latitude'].values)
    #axs.axis('equal')
    #fig.tight_layout()
    #fig.legend()
    #plt.show()

    p = initialize_base_plot(df, scale=1)

    source = ColumnDataSource(df)

    circle = p.circle(x='x', y='y', line_color=mapper, color=mapper, source=source,
                    hover_color='white', legend_field='seq_name', radius=scale * 3, fill_alpha=0.4)

    p.add_layout(Arrow(end=OpenHead(line_color="firebrick", line_width=scale * 4, size=scale * 10),
                    x_start='x', y_start='y', x_end='arrow_x', y_end='arrow_y', source=source))

    p.border_fill_color = "white"
    p.min_border_left = 200

    p.grid.visible = True

    m = p.add_tile(get_provider(ESRI_IMAGERY))
    m.level = 'underlay'

    p.xaxis.visible = False
    p.yaxis.visible = False
    p.title.text_font_size = "20px"

    event_hover = HoverTool(
        tooltips="""
        <div>
            <div>
                <img
                    src="@overlay" height="358" alt="@overlay" width="481"
                    style="float: left; margin: 0px 15px 15px 0px;"
                    border="2"
                ></img>
            </div>
            <div>
                <span style="font-size: 17px; font-weight: bold;">Point: @i</span>
                <span style="font-size: 15px; color: #966;">Time_stamp: [@time_stamp]</span>

                <span style="font-size: 15px; color: #966;">Seq_name: [@seq_name]</span>

            </div>
            <div>
                <span style="font-size: 15px;">Location</span>
                <span style="font-size: 10px; color: #696;">(@latitude, @longitude)</span>
            </div>
            <Direction>
                <span style="font-size: 15px;">Orientation</span>
                <span style="font-size: 10px; color: #696;">@orientation rad</span>
            </div>
        </div>
        """,
        mode='mouse',
        point_policy='follow_mouse',
        renderers=[circle])

    p.add_tools(event_hover)
    
    show(p)

    print(os.path.join(args.base_path, 's3li_map.html'))
    output_file(str(os.path.join(args.base_path, 's3li_map.html')))
